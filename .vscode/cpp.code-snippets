{
    "Initialize": {
        "prefix": [
            "initialize"
        ],
        "body": [
            "$BLOCK_COMMENT_START",
            "\t$CURRENT_DATE $CURRENT_MONTH_NAME $CURRENT_YEAR",
            "   ${TM_DIRECTORY/(.*Step)*([\\/\\\\])/ /g} ${TM_FILENAME_BASE}",
            "$BLOCK_COMMENT_END",
            "",
            "#ifndef __DEBUG__",
            "#pragma GCC optimize(\"Ofast\")",
            "#pragma GCC target(\"avx,avx2,fma\")",
            "#endif",
            "",
            "#undef __INTERACTIVE__",
            "",
            "#include <bits/stdc++.h>",
            "#define pb push_back",
            "#define mp make_pair ",
            "#define fr first",
            "#define sc second",
            "#define pyes cout << \"YES\" //\"Yes\"",
            "#define pno cout << \"NO\"   //\"No\"",
            "#define fastio ios_base::sync_with_stdio(0)",
            "#define untie cin.tie(0)",
            "#define rep(i, n) for (int i = 0; i < (n); i++)",
            "#define repe(i, n) for (int i = 1; i <= (n); i++)",
            "#define rrep(i, n) for (int i = (n)-1; i >= 0; i--)",
            "#define rrepe(i, n) for (int i = (n); i > 0; i--)",
            "#define ms(a, b) memset(a, b, sizeof a)",
            "#define a2z(x) (x).begin(), (x).end()",
            "#define z2a(x) (x).rbegin(), (x).rend()",
            "#define gsz(v) ((int)(v).size())",
            "#define MOD 1000000007 //998244353",
            "#define MAX 1000005",
            "",
            "#if !defined(__INTERACTIVE__) && !defined(__DEBUG__)",
            "#define endl \"\\n\"",
            "#endif",
            "",
            "using namespace std;",
            "",
            "typedef long long ll;",
            "typedef unsigned long long ull;",
            "",
            "using pii = pair<int, int>;",
            "using pll = pair<ll, ll>;",
            "",
            "using vb = vector<bool>;",
            "using vi = vector<int>;",
            "using vl = vector<ll>;",
            "using vpii = vector<pair<int, int>>;",
            "",
            "using vvb = vector<vector<bool>>;",
            "using vvi = vector<vector<int>>;",
            "using vvl = vector<vector<ll>>;",
            "using vvpii = vector<vector<pair<int, int>>>;",
            "",
            "using mii = map<int, int>;",
            "using umii = unordered_map<int, int>;",
            "using seti = set<int>;",
            "using useti = unordered_set<int>;",
            "",
            "int main()",
            "{",
            "\tfastio;",
            "#if !defined(__INTERACTIVE__) && !defined(__DEBUG__)",
            "\tuntie;",
            "#ifdef LOCAL_OUTPUT",
            "\tfreopen(LOCAL_OUTPUT, \"w\", stdout);",
            "#endif",
            "#ifdef LOCAL_INPUT",
            "\tfreopen(LOCAL_INPUT, \"r\", stdin);",
            "#endif",
            "#endif",
            "\t$0",
            "}",
            "\n$BLOCK_COMMENT_START",
            "-> Check for data types",
            "-> Fix macro",
            "-> Run test case",
            "-> Check the copied part",
            "-> Set or multiset?",
            "-> Check statement order",
            "-> Check simple logic errors",
            "-> Read problem statements carefully",
            "$BLOCK_COMMENT_END"
        ],
        "description": "Initializes cpp"
    },
    "Test Case": {
        "prefix": [
            "test_case"
        ],
        "body": [
            "int __tests;",
            "cin >> __tests;",
            "while (__tests--)",
            "\t__run_test();"
        ],
        "description": "Creates test case utility"
    },
    "Test Case Classic": {
        "prefix": [
            "classic_test_case"
        ],
        "body": [
            "int __tests;",
            "cin >> __tests;",
            "for (int __test_case = 1; __test_case <= __tests; __test_case++)",
            "\t__run_test(__test_case);"
        ],
        "description": "Creates classic version of test case utility"
    },
    "Run Test": {
        "prefix": [
            "run_tests"
        ],
        "body": [
            "inline void __run_test()",
            "{",
            "\t$0",
            "}"
        ],
        "description": "Creates test running function"
    },
    "Run Test Classic": {
        "prefix": [
            "classic_run_tests"
        ],
        "body": [
            "inline void __run_test(int &__test_case)",
            "{",
            "\t$0",
            "}"
        ],
        "description": "Creates classic version of test running function"
    },
    "IO Stream Insert": {
        "prefix": [
            "local_io"
        ],
        "body": [
            "#ifdef LOCAL_OUTPUT",
            "\tfreopen(LOCAL_OUTPUT, \"w\", stdout);",
            "#endif",
            "#ifdef LOCAL_INPUT",
            "\tfreopen(LOCAL_INPUT, \"r\", stdin);",
            "#endif\n"
        ],
        "description": "Sets up local streams"
    },
    "IO Utility": {
        "prefix": [
            "io_util"
        ],
        "body": [
            "\n/***********IO Utility**************/",
            "template <typename... ArgTypes>",
            "void print(ArgTypes... args);",
            "template <typename... ArgTypes>",
            "void input(ArgTypes &...args);",
            "template <>",
            "void print() {}",
            "template <>",
            "void input() {}",
            "template <typename T, typename... ArgTypes>",
            "void print(T t, ArgTypes... args)",
            "{\n\tcout << t;",
            "\tprint(args...);\n}",
            "template <typename T, typename... ArgTypes>",
            "void input(T &t, ArgTypes &...args)",
            "{\n\tcin >> t;",
            "\tinput(args...);\n}"
        ],
        "description": "IO itility support"
    },
    "Modular Arithmetic": {
        "prefix": [
            "modular_arithmetic"
        ],
        "body": [
            "template <int mod>",
            "struct Mod",
            "{",
            "    long long x;",
            "    Mod() : x(0) {}",
            "    Mod(long long xx) : x(xx)",
            "    {",
            "        if (abs(x) >= mod)",
            "            x %= mod;",
            "        if (x < 0)",
            "            x += mod;",
            "    }",
            "    operator int() const { return x; }",
            "    operator long long() const { return x; }",
            "    Mod operator+(const Mod &a) const",
            "    {",
            "        Mod n;",
            "        n.x = x + a.x;",
            "        if (n.x >= mod)",
            "            n.x -= mod;",
            "        return n;",
            "    }",
            "    Mod operator-(const Mod &a) const",
            "    {",
            "        Mod n;",
            "        n.x = x - a.x;",
            "        if (n.x < 0)",
            "            n.x += mod;",
            "        return n;",
            "    }",
            "    Mod operator*(const Mod &a) const",
            "    {",
            "        return x * a.x;",
            "    }",
            "    Mod operator+=(const Mod &a)",
            "    {",
            "        x += a.x;",
            "        if (x >= mod)",
            "            x -= mod;",
            "        return *this;",
            "    }",
            "    Mod operator-=(const Mod &a)",
            "    {",
            "        x -= a.x;",
            "        if (x < 0)",
            "            x += mod;",
            "        return *this;",
            "    }",
            "    Mod operator++()",
            "    {",
            "        *this += 1;",
            "        return *this;",
            "    }",
            "    Mod operator++(int) //postfix",
            "    {",
            "        Mod temp = *this;",
            "        *this += 1;",
            "        return temp;",
            "    }",
            "    Mod operator--()",
            "    {",
            "        *this -= 1;",
            "        return *this;",
            "    }",
            "    Mod operator--(int) //postfix",
            "    {",
            "        Mod temp = *this;",
            "        *this -= 1;",
            "        return temp;",
            "    }",
            "    Mod operator*=(const Mod &a)",
            "    {",
            "        x = (x * a.x) % mod;",
            "        return *this;",
            "    }",
            "    Mod pow(long long b) const",
            "    {",
            "        Mod ans = 1;",
            "        Mod a = *this;",
            "        while (b > 0)",
            "        {",
            "            if (b & 1)",
            "                ans *= a;",
            "            a *= a;",
            "            b /= 2;",
            "        }",
            "        return ans;",
            "    }",
            "    Mod inv() const",
            "    {",
            "        return pow(mod - 2);",
            "    }",
            "    Mod operator/(const Mod &a) const",
            "    {",
            "        return (*this) * a.inv();",
            "    }",
            "    Mod operator/=(const Mod &a)",
            "    {",
            "        return (*this) *= a.inv();",
            "    }",
            "    bool operator==(const Mod &o) const",
            "    {",
            "        return x == o.x;",
            "    }",
            "    bool operator!=(const Mod &o) const",
            "    {",
            "        return x != o.x;",
            "    }",
            "    long long operator()() const",
            "    {",
            "        return x;",
            "    }",
            "    template <int _mod>",
            "    friend ostream &operator<<(ostream &os, const Mod<_mod> &num)",
            "    {",
            "        os << num.x;",
            "        return os;",
            "    }",
            "    template <int _mod>",
            "    friend istream &operator>>(istream &is, Mod<_mod> &num)",
            "    {",
            "        is >> num.x;",
            "        if (abs(num.x) >= mod)",
            "            num.x %= mod;",
            "        if (num.x < 0)",
            "            num.x += mod;",
            "        return is;",
            "    }",
            "};",
            "using base = Mod<MOD>;",
            "using vbase = vector<base>;",
            "using vvbase = vector<vector<base>>;",
            "base two = 2;",
        ],
        "description": "Modular arithmetic class"
    },
    "Y Combinator": {
        "prefix": [
            "y_combinator_support"
        ],
        "body": [
            "namespace std",
            "{",
            "",
            "    template <class Fun>",
            "    class y_combinator_result",
            "    {",
            "        Fun fun_;",
            "",
            "    public:",
            "        template <class T>",
            "        explicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {}",
            "",
            "        template <class... Args>",
            "        decltype(auto) operator()(Args &&...args)",
            "        {",
            "            return fun_(std::ref(*this), std::forward<Args>(args)...);",
            "        }",
            "    };",
            "",
            "    template <class Fun>",
            "    decltype(auto) y_combinator(Fun &&fun)",
            "    {",
            "        return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));",
            "    }",
            "",
            "}",
        ],
        "description": "Y combinator class support"
    },
    "Codeforces Link": {
        "prefix": [
            "codeforces_link"
        ],
        "body": [
            "// https://codeforces.com/problemset/problem/${TM_FILENAME_BASE/([0123456789]*)[A-Z].*$/$1/}/${TM_FILENAME_BASE/[0123456789]*([A-Z].*$)/$1/}"
        ],
        "description": "Y combinator class support"
    }
}